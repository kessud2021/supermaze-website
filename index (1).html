<!-- SuperMaze v1.2.0 - Made by VSSCO -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SuperMaze v1.2.0</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    /* --- Layout --- */
    html,body { height:100%; margin:0; font-family: 'Segoe UI', sans-serif; }
    body { display:flex; justify-content:center; align-items:center; transition: background .3s ease; min-height:100vh; }

    .connect-container { display:flex; justify-content:center; align-items:center; height:100%; }
    .connect-card { width:360px; border-radius:14px; box-shadow:0 8px 20px rgba(0,0,0,.18); }

    /* Maze area (fills page when visible) */
    .maze-container { width:100%; height:100vh; position:relative; display:flex; justify-content:center; align-items:center; background:#f5f5f5; overflow:hidden; }
    .maze-grid { display:grid; gap:2px; }

    /* Cell visuals */
    .cell { width:25px; height:25px; border-radius:6px; background:#fff; transition: background .06s; box-sizing:border-box; }
    .cell.wall { background:#333; }
    .cell.player { background:#e74c3c; box-shadow:0 0 6px rgba(231,76,60,.7) inset; }
    .cell.end { background:#2ecc71; box-shadow:0 0 6px rgba(46,204,113,.6) inset; }
    .cell.ghost { background: rgba(0,200,255,0.6); }

    /* HUD */
    .keystrokes { position:absolute; bottom:18px; left:18px; display:flex; gap:6px; flex-direction:column; color:#fff; font-weight:700; text-shadow:0 0 5px #000; }
    .keystrokes span { width:34px; height:34px; text-align:center; line-height:34px; border-radius:6px; border:1px solid rgba(255,255,255,.9); background:rgba(0,0,0,.55); }

    .stopwatch { position:absolute; top:14px; right:14px; padding:6px 10px; border-radius:8px; background:rgba(0,0,0,.7); color:#fff; font-size:18px; }
    .back-btn { position:absolute; top:14px; left:14px; }

    /* themes */
    body.theme-light { background: linear-gradient(180deg,#fff,#f0f4ff); color:#111; }
    body.theme-dark { background: #0f1113; color:#eee; }
    body.theme-blue { background: linear-gradient(180deg,#89f7fe,#66a6ff); }
    body.theme-green { background: linear-gradient(180deg,#a8e063,#56ab2f); }
    body.theme-pink { background: linear-gradient(180deg,#fbc2eb,#a6c1ee); }
    body.theme-red { background: linear-gradient(180deg,#ff9a9e,#f6416c); }

    /* small responsiveness */
    @media (max-width:480px) {
      .connect-card { width:92%; }
    }
  </style>
</head>
<body class="theme-light">

  <!-- USERNAME SCREEN -->
  <div id="username-screen" class="connect-container">
    <div class="card connect-card text-center">
      <div class="card-header"><h4 class="mb-0">Enter Username</h4></div>
      <div class="card-body">
        <input id="username-input" class="form-control mb-3" placeholder="Your username" />
        <button id="continue-btn" class="btn btn-primary w-100">Continue</button>
      </div>
    </div>
  </div>

  <!-- MAIN MENU -->
  <div id="connect-screen" class="connect-container d-none">
    <div class="card connect-card">
      <div class="card-header text-center">
        <h3 class="mb-0">ðŸŒ€ SuperMaze</h3>
        <small class="text-muted">Version 1.2.0 - Beta</small>
      </div>
      <div class="card-body text-center">
        <button id="single-btn" class="btn btn-success w-100 mb-2">Singleplayer</button>
        <button id="replay-list-btn" class="btn btn-outline-primary w-100 mb-2">Saved Replays</button>

        <select id="theme-select" class="form-select mb-3">
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="pink">Pink</option>
          <option value="red">Red</option>
        </select>

        <div id="xp-info" class="mb-2 text-muted"></div>
        <button id="leaderboard-btn" class="btn btn-outline-secondary w-100">Leaderboard</button>
      </div>
    </div>
  </div>

  <!-- MAZE SCREEN -->
  <div id="maze-screen" class="maze-container d-none">
    <div id="maze-grid" class="maze-grid" aria-hidden="false"></div>
    <div id="keystrokes" class="keystrokes"></div>
    <div id="stopwatch" class="stopwatch">00:00.000</div>
    <button id="back-btn" class="btn btn-secondary back-btn">Exit</button>
  </div>

<script>
/* SuperMaze v1.2.0 - JS
   - Solvable maze generator (Recursive Backtracker)
   - Movement recording + replay using timestamps
   - Clean UI state handling
*/

/* ---------------- DOM refs ---------------- */
const usernameScreen = document.getElementById('username-screen');
const usernameInput = document.getElementById('username-input');
const continueBtn = document.getElementById('continue-btn');
const connectScreen = document.getElementById('connect-screen');
const mazeScreen = document.getElementById('maze-screen');

const mazeGrid = document.getElementById('maze-grid');
const themeSelect = document.getElementById('theme-select');
const xpInfo = document.getElementById('xp-info');
const singleBtn = document.getElementById('single-btn');
const replayListBtn = document.getElementById('replay-list-btn');
const leaderboardBtn = document.getElementById('leaderboard-btn');
const backBtn = document.getElementById('back-btn');
const keystrokesDiv = document.getElementById('keystrokes');
const stopwatchDisplay = document.getElementById('stopwatch');

/* ---------------- Game settings ---------------- */
// Use an odd size for maze carving; makes the carve-at-odd-indexes algorithm easier.
// You may change this but prefer odd numbers (e.g., 21, 31).
const size = 21;             // grid width/height (must be odd for the generator to work as-is)
const cellPx = 25;           // pixel size per cell
let cellCount = size * size;

/* ---------------- State ---------------- */
let username = localStorage.getItem('maze_username') || '';
let maze = [];               // 2D array: 1=wall,0=space (carved)
let player = {x:1,y:1};
let endCell = {x:size-2,y:size-2};

let moving = false;
let gameWon = false;

let startTime = null;
let timerInterval = null;

let moves = [];              // {x,y,t} recorded during run (t = ms since startTime)
let replayMode = false;

let xp = parseInt(localStorage.getItem('maze_xp')) || 0;
let level = Math.floor(xp / 100);
let leaderboard = JSON.parse(localStorage.getItem('maze_leaderboard') || '[]');

/* ---------------- Utility helpers ---------------- */
function clone2D(arr) { return arr.map(row => row.slice()); }
function now() { return performance.now(); }
function formatTime(ms) {
  if (ms === null || ms === undefined) return "00:00.000";
  const totalSeconds = ms / 1000;
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = Math.floor(totalSeconds % 60);
  const millis = Math.floor(ms % 1000);
  return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(millis).padStart(3,'0')}`;
}

/* ---------------- Init UI on load ---------------- */
function updateXPDisplay() { xpInfo.textContent = `${username || 'Guest'} | Level ${level} | XP: ${xp}`; }
updateXPDisplay();

// if user already exists, skip username screen
if (username) {
  usernameScreen.classList.add('d-none');
  connectScreen.classList.remove('d-none');
} else {
  usernameScreen.classList.remove('d-none');
}

// theme select: set initial state from body class
(function setInitialTheme() {
  const body = document.body;
  const match = body.className.match(/theme-[a-z]+/);
  if (match) {
    const val = match[0].replace('theme-','');
    themeSelect.value = val;
  } else themeSelect.value = 'light';
})();

/* ---------------- Username / Menu handlers ---------------- */
continueBtn.onclick = () => {
  const name = usernameInput.value.trim();
  if (!name) return alert('Enter a username!');
  username = name;
  localStorage.setItem('maze_username', username);
  usernameScreen.classList.add('d-none');
  connectScreen.classList.remove('d-none');
  updateXPDisplay();
};

themeSelect.onchange = () => {
  document.body.className = 'theme-' + themeSelect.value;
};

/* ---------------- Maze generator (Recursive Backtracker) ----------------
   We create a grid initialized with walls (1). We carve passages at odd indices.
   This guarantees a perfect maze (single path between any two open cells),
   so every path between two open cells exists â€” solvable.
*/
function initWallGrid() {
  maze = new Array(size);
  for (let y=0;y<size;y++) {
    maze[y] = new Array(size).fill(1); // all walls initially
  }
}

// carve maze using DFS stack
function carveMaze() {
  initWallGrid();

  const stack = [];
  // start at (1,1)
  const start = {x:1,y:1};
  maze[start.y][start.x] = 0;
  stack.push(start);

  const dirs = [
    {dx:0,dy:-2}, // up
    {dx:2,dy:0},  // right
    {dx:0,dy:2},  // down
    {dx:-2,dy:0}  // left
  ];

  while (stack.length) {
    const cur = stack[stack.length-1];
    // collect unvisited neighbors (two steps away)
    const neighbors = [];
    for (const d of dirs) {
      const nx = cur.x + d.dx;
      const ny = cur.y + d.dy;
      if (ny>0 && ny<size-1 && nx>0 && nx<size-1 && maze[ny][nx] === 1) neighbors.push({x:nx,y:ny,via:d});
    }
    if (neighbors.length === 0) {
      stack.pop();
    } else {
      const n = neighbors[Math.floor(Math.random()*neighbors.length)];
      // carve passage between cur and n
      const betweenX = cur.x + n.via.dx/2;
      const betweenY = cur.y + n.via.dy/2;
      maze[betweenY][betweenX] = 0;
      maze[n.y][n.x] = 0;
      stack.push({x:n.x,y:n.y});
    }
  }
}

/* Place player and end in open cells far apart */
function placePlayerAndEnd() {
  // find random empty cell
  function randomEmpty() {
    let attempts = 0;
    while (attempts++ < 10000) {
      const x = 1 + Math.floor(Math.random() * (size-2));
      const y = 1 + Math.floor(Math.random() * (size-2));
      if (maze[y][x] === 0) return {x,y};
    }
    // fallback
    return {x:1,y:1};
  }

  player = randomEmpty();
  endCell = randomEmpty();

  // ensure distance: Manhattan distance >= (size/2)
  let tries = 0;
  while ((Math.abs(player.x-endCell.x) + Math.abs(player.y-endCell.y) ) < Math.floor(size/2) && tries++ < 2000) {
    endCell = randomEmpty();
  }
}

/* Full generate function (carve + place) */
function generateMaze() {
  carveMaze();
  placePlayerAndEnd();
}

/* ---------------- Rendering ---------------- */
function renderMaze(ghostPos = null) {
  mazeGrid.innerHTML = '';
  mazeGrid.style.gridTemplateColumns = `repeat(${size}, ${cellPx}px)`;
  mazeGrid.style.gridTemplateRows = `repeat(${size}, ${cellPx}px)`;
  // create fragment for performance
  const frag = document.createDocumentFragment();
  for (let y=0;y<size;y++) {
    for (let x=0;x<size;x++) {
      const d = document.createElement('div');
      d.className = 'cell';
      if (maze[y][x] === 1) d.classList.add('wall');
      if (x === player.x && y === player.y && !(ghostPos && ghostPos.x === x && ghostPos.y === y)) d.classList.add('player');
      if (x === endCell.x && y === endCell.y) d.classList.add('end');
      if (ghostPos && ghostPos.x === x && ghostPos.y === y) d.classList.add('ghost');
      frag.appendChild(d);
    }
  }
  mazeGrid.appendChild(frag);
}

/* ---------------- Movement & keys ---------------- */
const keys = {
  w:false,a:false,s:false,d:false,
  ArrowUp:false,ArrowDown:false,ArrowLeft:false,ArrowRight:false
};

const arrowMap = { W:'ArrowUp', A:'ArrowLeft', S:'ArrowDown', D:'ArrowRight' };

function updateKeystrokes() {
  const layout = ['W','A','S','D'];
  keystrokesDiv.innerHTML = '';
  layout.forEach(k => {
    const span = document.createElement('span');
    span.textContent = k;
    const lower = k.toLowerCase();
    const arrow = arrowMap[k];
    if (keys[lower] || keys[arrow]) span.style.background = 'limegreen';
    keystrokesDiv.appendChild(span);
  });
}

// single-step move (not continuous) on keydown
document.addEventListener('keydown', (e) => {
  if (replayMode || gameWon) return;
  // avoid text inputs capturing keys: if focus on input, ignore movement
  if (document.activeElement && document.activeElement.tagName === 'INPUT') return;

  const key = e.key;
  // only process WASD and arrows
  if (!['w','a','s','d','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(key)) return;

  // prevent default behaviors like scrolling
  e.preventDefault();

  // if already pressed, ignore repeated events to avoid multiple moves from key repeat
  if (keys[key]) return;
  keys[key] = true;
  updateKeystrokes();

  // start stopwatch on first move
  if (!startTime) startStopwatch();

  let nx = player.x, ny = player.y;
  if (key === 'w' || key === 'ArrowUp') ny--;
  if (key === 's' || key === 'ArrowDown') ny++;
  if (key === 'a' || key === 'ArrowLeft') nx--;
  if (key === 'd' || key === 'ArrowRight') nx++;

  // check bounds & wall
  if (maze[ny] && maze[ny][nx] === 0) {
    player.x = nx; player.y = ny;
    // push move: time since start
    const t = startTime ? Math.max(0, Math.round(now() - startTime)) : 0;
    moves.push({x:nx,y:ny,t});
    renderMaze();
    checkVictory();
  }
});

document.addEventListener('keyup', (e) => {
  if (['w','a','s','d','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
    keys[e.key] = false;
    updateKeystrokes();
  }
});

/* ---------------- Stopwatch ---------------- */
function startStopwatch() {
  startTime = now();
  stopwatchDisplay.textContent = formatTime(0);
  timerInterval = setInterval(() => {
    const elapsed = Math.round(now() - startTime);
    stopwatchDisplay.textContent = formatTime(elapsed);
  }, 30);
}
function stopStopwatch() { clearInterval(timerInterval); timerInterval = null; }
function resetStopwatch() { stopStopwatch(); startTime = null; stopwatchDisplay.textContent = "00:00.000"; }

/* ---------------- Victory / Save ---------------- */
function checkVictory() {
  if (player.x === endCell.x && player.y === endCell.y && !gameWon) {
    gameWon = true;
    stopStopwatch();
    const totalTime = Math.round(now() - (startTime || now()));
    // award XP
    addXP(50);
    saveRun(totalTime);
    showVictory(totalTime);
  }
}

function showVictory(totalTime) {
  const overlay = document.createElement('div');
  Object.assign(overlay.style, {
    position:'absolute', inset:'0', display:'flex', flexDirection:'column', justifyContent:'center', alignItems:'center',
    background:'rgba(0,0,0,0.8)', zIndex:9999
  });
  const title = document.createElement('h1');
  title.innerText = 'ðŸ† VICTORY!';
  title.style.color = 'gold';
  title.style.fontSize = '48px';
  const timeText = document.createElement('h4');
  timeText.innerText = `Time: ${formatTime(totalTime)}`;
  timeText.style.color = '#fff';
  const replayBtn = document.createElement('button');
  replayBtn.className = 'btn btn-primary mt-3';
  replayBtn.textContent = 'Replay Run';
  replayBtn.onclick = () => {
    overlay.remove();
    const last = leaderboard[leaderboard.length-1];
    if (last) playReplay(last);
  };
  const menuBtn = document.createElement('button');
  menuBtn.className = 'btn btn-secondary mt-3';
  menuBtn.textContent = 'Return to Menu';
  menuBtn.onclick = () => {
    overlay.remove();
    mazeScreen.classList.add('d-none');
    connectScreen.classList.remove('d-none');
    resetGame();
  };
  overlay.append(title, timeText, replayBtn, menuBtn);
  mazeScreen.appendChild(overlay);
}

/* Save run: include username, time, moves, xp awarded and maze snapshot so replays show correctly */
function saveRun(time) {
  const run = {
    username: username || 'Guest',
    time,
    moves: moves.slice(),      // shallow copy of moves array (objects immutableish)
    xp,
    date: new Date().toISOString(),
    mazeSnapshot: clone2D(maze), // store maze so replay shows exact layout
    startPos: { ...moves.length ? moves[0] : player } // helpful for replay
  };
  leaderboard.push(run);
  localStorage.setItem('maze_leaderboard', JSON.stringify(leaderboard));
}

/* ---------------- Replay playback ----------------
   Accepts a run object created by saveRun().
   Recreates the maze from the snapshot and animates the ghost along recorded timestamps.
*/
function playReplay(run) {
  if (!run || !run.moves || run.moves.length === 0) {
    alert('No moves recorded for this run.');
    return;
  }
  replayMode = true;
  // load maze snapshot & place ghost start
  maze = clone2D(run.mazeSnapshot);
  const ghostMoves = run.moves;
  let i = 0;
  renderMaze(ghostMoves[0]); // draw initial ghost
  mazeScreen.classList.remove('d-none');
  connectScreen.classList.add('d-none');

  // Use setTimeout scheduling based on recorded 't' values.
  // We'll schedule each rendering relative to the first move's time (which is usually 0).
  const startT = ghostMoves[0].t || 0;
  const base = now();

  function scheduleNext(idx) {
    if (idx >= ghostMoves.length) {
      // finish
      replayMode = false;
      // show final position for a moment then go back to menu
      setTimeout(()=> {
        resetGame();
        mazeScreen.classList.add('d-none');
        connectScreen.classList.remove('d-none');
      }, 700);
      return;
    }
    const target = ghostMoves[idx];
    const delay = Math.max(0, (target.t - startT) - (now() - base));
    setTimeout(() => {
      renderMaze({x:target.x,y:target.y});
      scheduleNext(idx+1);
    }, delay);
  }

  scheduleNext(0);
}

/* ---------------- Start/Reset flows ---------------- */
function resetGame() {
  gameWon = false;
  startTime = null;
  resetStopwatch();
  moves = [];
  replayMode = false;
  // re-render will happen when new maze created or menu shown
}

/* Singleplayer start */
singleBtn.onclick = () => {
  resetGame();
  generateMaze();
  // record starting position as first move at t = 0
  const start = { x: player.x, y: player.y, t: 0 };
  moves = [ start ];
  renderMaze();
  connectScreen.classList.add('d-none');
  mazeScreen.classList.remove('d-none');
  updateXPDisplay();
};

/* Leaderboard UI (simple alert, show top 10) */
leaderboardBtn.onclick = () => {
  if (!leaderboard.length) return alert('Leaderboard empty.');
  const sorted = leaderboard.slice().sort((a,b)=>a.time-b.time).slice(0,10);
  const text = sorted.map((r,i)=> `${i+1}. ${r.username} - ${formatTime(r.time)} (${new Date(r.date).toLocaleString()})`).join('\n');
  alert('ðŸ Leaderboard:\n' + text);
};

/* Replay list button: show saved runs and allow playing them */
replayListBtn.onclick = () => {
  if (!leaderboard.length) return alert('No saved runs.');
  // show simple menu via prompt-style selection
  const options = leaderboard.map((r,i)=> `${i+1}. ${r.username} - ${formatTime(r.time)} (${new Date(r.date).toLocaleString()})`).join('\n');
  const idx = prompt('Saved runs:\n' + options + '\n\nEnter run number to play:');
  const n = parseInt(idx);
  if (!n || n < 1 || n > leaderboard.length) return;
  const run = leaderboard[n-1];
  playReplay(run);
};

/* Back to menu */
backBtn.onclick = () => {
  resetGame();
  mazeScreen.classList.add('d-none');
  connectScreen.classList.remove('d-none');
};

/* XP system */
function addXP(amount) {
  xp += amount;
  localStorage.setItem('maze_xp', xp);
  level = Math.floor(xp / 100);
  updateXPDisplay();
}

/* ---------------- On window load/set initial tiny behaviors ---------------- */
window.addEventListener('load', () => {
  // ensure theme select and body are in-sync
  document.body.className = 'theme-' + themeSelect.value;
  updateXPDisplay();
});
</script>
</body>
</html>
